{"version":3,"file":"HistoryService.js","sources":["../src/utils/Utils.js","../src/services/StorageService.js","../src/services/ApiService.js","../src/utils/AuthDebugger.js","../src/services/HistoryService.js"],"sourcesContent":["// Utils.js\r\n\r\nexport class Utils {\r\n    static capitalizeFirst(str) {\r\n        return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';\r\n    }\r\n\r\n    static async delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    static parseURLParams() {\r\n        const urlParams = new URLSearchParams(window.location.search);\r\n        return {\r\n            id: parseInt(urlParams.get('id')) || 25,\r\n            name: urlParams.get('name'),\r\n            caughtAt: urlParams.get('caughtAt'),\r\n            site: urlParams.get('site'),\r\n            shiny: urlParams.get('shiny') === 'true'\r\n        };\r\n    }\r\n\r\n    // Formats a date string into a relative time format (e.g., \"2 days ago\").\r\n    static formatDate(dateString) {\r\n        const diffMinutes = Math.floor((new Date() - new Date(dateString)) / 60000);\r\n        if (diffMinutes < 1) return 'Just now';\r\n        if (diffMinutes < 60) return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''} ago`;\r\n        const diffHours = Math.floor(diffMinutes / 60);\r\n        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n        const diffDays = Math.floor(diffHours / 24);\r\n        return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n    }\r\n\r\n    /**\r\n     * Generates a hash for a collection of Pok√©mon.\r\n     * @param {Array} collection - The collection to hash.\r\n     * @returns {string} - The generated hash.\r\n     */\r\n    static generateCollectionHash(collection) {\r\n        if (!collection?.length) return 'empty';\r\n        \r\n        const sortedString = collection\r\n            .map(p => `${p.id}-${p.site}-${new Date(p.caughtAt).getTime()}`)\r\n            .sort()\r\n            .join('|');\r\n        \r\n        let hash = 0;\r\n        for (let i = 0; i < sortedString.length; i++) {\r\n            hash = (hash << 5) - hash + sortedString.charCodeAt(i);\r\n            hash |= 0; // Convert to 32-bit integer\r\n        }\r\n        return hash.toString(36);\r\n    }\r\n}\r\n","/**\r\n * Service for handling interactions with Chrome's local storage.\r\n */\r\nexport class StorageService {\r\n    /**\r\n     * Retrieves the Pok√©mon collection from local storage.\r\n     * @returns {Promise<Array>} - The Pok√©mon collection.\r\n     */\r\n    static async getPokemonCollection() {\r\n        const { pokemonCollection = [] } = await chrome.storage.local.get(['pokemonCollection']);\r\n        return pokemonCollection;\r\n    }\r\n\r\n    /**\r\n     * Saves the Pok√©mon collection to local storage.\r\n     * @param {Array} collection - The Pok√©mon collection to save.\r\n     */\r\n    static async setPokemonCollection(collection) {\r\n        await chrome.storage.local.set({ pokemonCollection: collection });\r\n    }\r\n\r\n    /**\r\n     * Removes a Pok√©mon from the collection in local storage.\r\n     * @param {Object} pokemonToRemove - The Pok√©mon to remove.\r\n     * @returns {Promise<boolean>} - True if a Pok√©mon was removed, false otherwise.\r\n     */\r\n    static async removePokemonFromCollection(pokemonToRemove) {\r\n        const collection = await this.getPokemonCollection();\r\n        const initialLength = collection.length;\r\n        \r\n        const updatedCollection = collection.filter(p => \r\n            !(p.id === pokemonToRemove.id && \r\n              p.site === pokemonToRemove.site && \r\n              new Date(p.caughtAt).getTime() === new Date(pokemonToRemove.caughtAt).getTime())\r\n        );\r\n        \r\n        await this.setPokemonCollection(updatedCollection);\r\n        return updatedCollection.length < initialLength;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the Pok√©mon history from local storage.\r\n     * @returns {Promise<Array>} - Array of Pokemon IDs that were ever caught.\r\n     */\r\n    static async getPokemonHistory() {\r\n        const { pokemonHistory = [] } = await chrome.storage.local.get(['pokemonHistory']);\r\n        return pokemonHistory;\r\n    }\r\n\r\n    /**\r\n     * Saves the Pok√©mon history to local storage.\r\n     * @param {Array} history - Array of Pokemon IDs to save.\r\n     */\r\n    static async setPokemonHistory(history) {\r\n        await chrome.storage.local.set({ pokemonHistory: history });\r\n    }\r\n\r\n    /**\r\n     * Adds a Pokemon ID to the history in local storage.\r\n     * @param {number} pokemonId - The Pokemon ID to add to history.\r\n     * @returns {Promise<boolean>} - True if Pokemon was added, false if already existed.\r\n     */\r\n    static async addToHistory(pokemonId) {\r\n        const history = await this.getPokemonHistory();\r\n        \r\n        // Check if Pokemon is already in history\r\n        if (history.includes(pokemonId)) {\r\n            return false; // Already exists\r\n        }\r\n        \r\n        // Add to history and save\r\n        history.push(pokemonId);\r\n        await this.setPokemonHistory(history);\r\n        return true; // Successfully added\r\n    }\r\n}\r\n","import { CONFIG } from '../shared/config.js';\r\n\r\n// Service for handling API requests.\r\nexport class APIService {\r\n    static async fetchAllPokemon(limit = 151) {\r\n        try {\r\n            const response = await fetch(`${CONFIG.POKEAPI_BASE_URL}?limit=${limit}`);\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch Pok√©mon list: ${response.status}`);\r\n            }\r\n            const data = await response.json();\r\n            return data.results.map((p, index) => ({\r\n                id: index + 1,\r\n                name: p.name,\r\n                caught: false\r\n            }));\r\n        } catch (error) {\r\n            console.error('Error fetching all Pok√©mon:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches Pok√©mon data from the Pok√©API.\r\n     * @param {number} pokemonId - The ID of the Pok√©mon to fetch.\r\n     * @param {Map} cache - The cache to store and retrieve data from.\r\n     * @returns {Promise<Object>} - The Pok√©mon data.\r\n     */\r\n    static async fetchPokemonData(pokemonId, cache) {\r\n        const cacheKey = `pokemon_${pokemonId}`;\r\n        if (cache.has(cacheKey)) {\r\n            return cache.get(cacheKey);\r\n        }\r\n\r\n        try {\r\n            const response = await fetch(`${CONFIG.POKEAPI_BASE_URL}/${pokemonId}`);\r\n            if (!response.ok) {\r\n                throw new Error(`Pokemon not found: ${response.status}`);\r\n            }\r\n            \r\n            const data = await response.json();\r\n            cache.set(cacheKey, data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error('Error fetching Pokemon data:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    static async fetchSpeciesData(pokemonId, cache) {\r\n        const cacheKey = `species_${pokemonId}`;\r\n        if (cache.has(cacheKey)) {\r\n            return cache.get(cacheKey);\r\n        }\r\n\r\n        try {\r\n            const pokemonData = await this.fetchPokemonData(pokemonId, cache);\r\n            const response = await fetch(pokemonData.species.url);\r\n            if (!response.ok) {\r\n                throw new Error(`Species not found: ${response.status}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n            cache.set(cacheKey, data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error('Error fetching species data:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Utility for debugging authentication issues\r\n */\r\nexport class AuthDebugger {\r\n    /**\r\n     * Logs detailed authentication state across all components\r\n     * @param {string} context - Where this debug is being called from\r\n     * @param {AppState} appState - The app state to debug\r\n     */\r\n    static logAuthState(context, appState) {\r\n        console.group(`üîç Auth Debug - ${context}`);\r\n        \r\n        const status = appState.getAuthStatus();\r\n        console.log('üìä Auth Status:', status);\r\n        \r\n        // Check Supabase client state\r\n        if (appState.supabase) {\r\n            console.log('‚úÖ Supabase client exists');\r\n            console.log('üîó Supabase URL:', appState.supabase.supabaseUrl);\r\n        } else {\r\n            console.log('‚ùå Supabase client missing');\r\n        }\r\n        \r\n        // Check user state\r\n        if (appState.currentUser) {\r\n            console.log('‚úÖ User logged in:', {\r\n                id: appState.currentUser.id,\r\n                email: appState.currentUser.email,\r\n                created_at: appState.currentUser.created_at\r\n            });\r\n        } else {\r\n            console.log('‚ùå No user logged in');\r\n        }\r\n        \r\n        // Check network state\r\n        console.log('üåê Network status:', navigator.onLine ? 'Online' : 'Offline');\r\n        \r\n        // Check initialization state\r\n        console.log('üöÄ App initialized:', appState.isInitialized);\r\n        \r\n        console.groupEnd();\r\n        \r\n        return status;\r\n    }\r\n    \r\n    /**\r\n     * Waits for authentication with detailed logging\r\n     * @param {AppState} appState - The app state to monitor\r\n     * @param {number} maxWaitTime - Maximum time to wait\r\n     * @param {string} context - Context for logging\r\n     */\r\n    static async waitForAuthWithLogging(appState, maxWaitTime = 5000, context = 'Unknown') {\r\n        console.log(`‚è≥ ${context}: Waiting for authentication...`);\r\n        \r\n        const startTime = Date.now();\r\n        let attempts = 0;\r\n        \r\n        while (Date.now() - startTime < maxWaitTime) {\r\n            attempts++;\r\n            const status = this.logAuthState(`${context} - Attempt ${attempts}`, appState);\r\n            \r\n            if (status.canSync) {\r\n                console.log(`‚úÖ ${context}: Authentication ready after ${attempts} attempts`);\r\n                return true;\r\n            }\r\n            \r\n            // Wait 500ms before next check\r\n            await new Promise(resolve => setTimeout(resolve, 500));\r\n        }\r\n        \r\n        console.log(`‚è∞ ${context}: Authentication timeout after ${attempts} attempts`);\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Tests candy service authentication\r\n     * @param {CandyService} candyService - The candy service to test\r\n     * @param {string} context - Context for logging\r\n     */\r\n    static async testCandyServiceAuth(candyService, context = 'Unknown') {\r\n        console.group(`üç¨ Candy Service Auth Test - ${context}`);\r\n        \r\n        try {\r\n            // Log the app state\r\n            this.logAuthState(`${context} - Before Candy Call`, candyService.state);\r\n            \r\n            // Try to get candy data\r\n            console.log('üîÑ Attempting to fetch candy data...');\r\n            const candyData = await candyService.getCandyForUser();\r\n            \r\n            console.log('‚úÖ Candy data fetch successful:', {\r\n                size: candyData.size,\r\n                entries: Array.from(candyData.entries()).slice(0, 3) // Show first 3 entries\r\n            });\r\n            \r\n        } catch (error) {\r\n            console.error('‚ùå Candy data fetch failed:', error);\r\n        }\r\n        \r\n        console.groupEnd();\r\n    }\r\n}\r\n","import { AuthDebugger } from '../utils/AuthDebugger.js';\r\nimport { StorageService } from './StorageService.js';\r\n\r\n/**\r\n * Service for handling Pokemon history operations.\r\n * Tracks all Pokemon that have ever been caught by a user.\r\n */\r\nexport class HistoryService {\r\n    /**\r\n     * @param {AppState} appState - The application state.\r\n     */\r\n    constructor(appState) {\r\n        this.state = appState;\r\n        this.maxRetries = 3;\r\n        this.retryDelay = 1000; // 1 second\r\n    }\r\n\r\n    /**\r\n     * Waits for authentication to be ready with retry logic.\r\n     * @param {number} maxWaitTime - Maximum time to wait in milliseconds.\r\n     * @returns {Promise<boolean>} - True if authenticated, false if timeout.\r\n     */\r\n    async waitForAuthentication(maxWaitTime = 5000) {\r\n        const startTime = Date.now();\r\n        \r\n        while (Date.now() - startTime < maxWaitTime) {\r\n            if (this.state.canSync()) {\r\n                console.log('‚úÖ Authentication ready for history operations');\r\n                return true;\r\n            }\r\n            \r\n            // Check what's missing for better debugging\r\n            const issues = [];\r\n            if (!this.state.currentUser) issues.push('user not logged in');\r\n            if (!this.state.supabase) issues.push('supabase not initialized');\r\n            if (!navigator.onLine) issues.push('browser offline');\r\n            \r\n            console.log(`‚è≥ Waiting for authentication... Issues: ${issues.join(', ')}`);\r\n            \r\n            // Wait 500ms before checking again\r\n            await new Promise(resolve => setTimeout(resolve, 500));\r\n        }\r\n        \r\n        console.log('‚è∞ Authentication wait timeout reached');\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Retrieves all Pokemon history for the current user from Supabase.\r\n     * @returns {Promise<Set>} - A set of Pokemon IDs that were ever caught.\r\n     */\r\n    async getHistoryForUser() {\r\n        // Debug authentication state before attempting history fetch\r\n        AuthDebugger.logAuthState('HistoryService.getHistoryForUser - Start', this.state);\r\n        \r\n        // First, try to wait for authentication if not immediately available\r\n        if (!this.state.canSync()) {\r\n            console.log('üîÑ Authentication not ready, waiting...');\r\n            const authReady = await AuthDebugger.waitForAuthWithLogging(\r\n                this.state, \r\n                5000, \r\n                'HistoryService.getHistoryForUser'\r\n            );\r\n            \r\n            if (!authReady) {\r\n                console.log('‚ùå Cannot sync history data - authentication timeout, using local data');\r\n                AuthDebugger.logAuthState('HistoryService.getHistoryForUser - Timeout', this.state);\r\n                return await this.getLocalHistory();\r\n            }\r\n        }\r\n\r\n        try {\r\n            console.log('üìö Fetching Pokemon history for user:', this.state.currentUser.email);\r\n\r\n            const { data: historyData, error } = await this.state.supabase\r\n                .from('pokemon_history')\r\n                .select('pokemon_id')\r\n                .eq('user_id', this.state.currentUser.id);\r\n\r\n            if (error) {\r\n                console.error('‚ùå Error fetching history data:', error);\r\n                console.log('üì± Falling back to local history data');\r\n                return await this.getLocalHistory();\r\n            }\r\n\r\n            const historySet = new Set();\r\n            if (historyData && historyData.length > 0) {\r\n                historyData.forEach(entry => {\r\n                    historySet.add(entry.pokemon_id);\r\n                });\r\n                console.log(`‚úÖ Loaded history data for ${historyData.length} Pokemon from Supabase`);\r\n                \r\n                // Update local storage with server data\r\n                await StorageService.setPokemonHistory(Array.from(historySet));\r\n            } else {\r\n                console.log('üì≠ No history data found for user in Supabase');\r\n            }\r\n\r\n            return historySet;\r\n        } catch (error) {\r\n            console.error('‚ùå Error fetching history data:', error);\r\n            console.log('üì± Falling back to local history data');\r\n            return await this.getLocalHistory();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a Pokemon was ever caught by the user\r\n     * @param {number} pokemonId - The Pokemon ID to check\r\n     * @returns {Promise<boolean>} - True if ever caught, false otherwise\r\n     */\r\n    async hasEverCaught(pokemonId) {\r\n        try {\r\n            const historySet = await this.getHistoryForUser();\r\n            return historySet.has(pokemonId);\r\n        } catch (error) {\r\n            console.error('‚ùå Error checking if Pokemon was ever caught:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the first caught data for a specific Pokemon\r\n     * @param {number} pokemonId - The Pokemon ID to get data for\r\n     * @returns {Promise<Object|null>} - The history record or null if not found\r\n     */\r\n    async getFirstCaughtData(pokemonId) {\r\n        // Quick check - if not authenticated, return null immediately\r\n        if (!this.state.isLoggedIn() || !this.state.supabase) {\r\n            console.log('‚ùå Not authenticated, cannot fetch first caught data');\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            console.log(`üìö Fetching first caught data for Pokemon ${pokemonId}`);\r\n            console.log(`üîç Query params: user_id=${this.state.currentUser.id}, pokemon_id=${pokemonId}`);\r\n\r\n            const { data, error } = await this.state.supabase\r\n                .from('pokemon_history')\r\n                .select('*')\r\n                .eq('user_id', this.state.currentUser.id)\r\n                .eq('pokemon_id', pokemonId)\r\n                .order('first_caught_at', { ascending: true })\r\n                .limit(1)\r\n                .single();\r\n\r\n            console.log(`üîç Raw query result - data:`, data, `error:`, error);\r\n\r\n            if (error) {\r\n                if (error.code === 'PGRST116') {\r\n                    console.log(`üì≠ No history found for Pokemon ${pokemonId}`);\r\n                    return null;\r\n                }\r\n                console.error('‚ùå Database error:', error);\r\n                return null;\r\n            }\r\n\r\n            // Check if data is null (no records found)\r\n            if (!data) {\r\n                console.log(`üì≠ No history record found for Pokemon ${pokemonId}`);\r\n                return null;\r\n            }\r\n\r\n            console.log(`‚úÖ Found history for Pokemon ${pokemonId}:`, data);\r\n            console.log(`üìÖ First caught date field:`, data.first_caught_at);\r\n            console.log(`üìÖ Date type:`, typeof data.first_caught_at);\r\n            return data;\r\n        } catch (error) {\r\n            console.error('‚ùå Error fetching first caught data:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a Pokemon to the user's history both locally and in Supabase.\r\n     * @param {number} pokemonId - The Pokemon ID to add to history.\r\n     * @returns {Promise<boolean>} - True if successfully added.\r\n     */\r\n    async addToHistory(pokemonId) {\r\n        try {\r\n            console.log(`üìö Adding Pokemon ${pokemonId} to history`);\r\n\r\n            // Always add to local storage first\r\n            await StorageService.addToHistory(pokemonId);\r\n            console.log(`‚úÖ Added Pokemon ${pokemonId} to local history`);\r\n\r\n            // Try to sync to Supabase if authenticated\r\n            if (this.state.canSync()) {\r\n                try {\r\n                    const { error } = await this.state.supabase\r\n                        .from('pokemon_history')\r\n                        .upsert({\r\n                            user_id: this.state.currentUser.id,\r\n                            pokemon_id: pokemonId\r\n                        }, {\r\n                            onConflict: 'user_id,pokemon_id'\r\n                        });\r\n\r\n                    if (error) {\r\n                        console.error(`‚ùå Error syncing Pokemon ${pokemonId} to Supabase:`, error);\r\n                        // Don't fail the operation, local storage succeeded\r\n                    } else {\r\n                        console.log(`‚úÖ Synced Pokemon ${pokemonId} to Supabase history`);\r\n                    }\r\n                } catch (syncError) {\r\n                    console.error(`‚ùå Error syncing Pokemon ${pokemonId} to Supabase:`, syncError);\r\n                    // Don't fail the operation, local storage succeeded\r\n                }\r\n            } else {\r\n                console.log(`üì± Not authenticated, Pokemon ${pokemonId} saved locally only`);\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error(`‚ùå Error adding Pokemon ${pokemonId} to history:`, error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Syncs local Pokemon history to Supabase.\r\n     * Called when user authenticates or comes online.\r\n     * @returns {Promise<boolean>} - True if sync successful.\r\n     */\r\n    async syncLocalHistory() {\r\n        if (!this.state.canSync()) {\r\n            console.log('‚ùå Cannot sync history - not authenticated');\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            console.log('üîÑ Syncing local Pokemon history to Supabase...');\r\n            \r\n            const localHistory = await StorageService.getPokemonHistory();\r\n            if (localHistory.length === 0) {\r\n                console.log('üì≠ No local history to sync');\r\n                return true;\r\n            }\r\n\r\n            // First, check which Pokemon are already in the cloud to avoid duplicates\r\n            const { data: existingHistory, error: fetchError } = await this.state.supabase\r\n                .from('pokemon_history')\r\n                .select('pokemon_id')\r\n                .eq('user_id', this.state.currentUser.id);\r\n\r\n            if (fetchError) {\r\n                console.error('‚ùå Error fetching existing history:', fetchError);\r\n                return false;\r\n            }\r\n\r\n            const existingPokemonIds = new Set(existingHistory?.map(h => h.pokemon_id) || []);\r\n            const newPokemonIds = localHistory.filter(id => !existingPokemonIds.has(id));\r\n\r\n            if (newPokemonIds.length === 0) {\r\n                console.log('‚úÖ All local history already exists in Supabase, clearing local storage');\r\n                await StorageService.setPokemonHistory([]);\r\n                return true;\r\n            }\r\n\r\n            // Prepare batch insert data for only new Pokemon\r\n            const historyRecords = newPokemonIds.map(pokemonId => ({\r\n                user_id: this.state.currentUser.id,\r\n                pokemon_id: pokemonId\r\n            }));\r\n\r\n            const { error } = await this.state.supabase\r\n                .from('pokemon_history')\r\n                .insert(historyRecords);\r\n\r\n            if (error) {\r\n                console.error('‚ùå Error syncing local history to Supabase:', error);\r\n                return false;\r\n            }\r\n\r\n            console.log(`‚úÖ Successfully synced ${newPokemonIds.length} new Pokemon to Supabase history`);\r\n            \r\n            // Clear local history after successful sync\r\n            await StorageService.setPokemonHistory([]);\r\n            console.log('‚úÖ Cleared local history after successful sync');\r\n            \r\n            return true;\r\n        } catch (error) {\r\n            console.error('‚ùå Error syncing local history:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets local Pokemon history as a fallback.\r\n     * @returns {Promise<Set>} - A set of Pokemon IDs from local storage.\r\n     */\r\n    async getLocalHistory() {\r\n        try {\r\n            const localHistory = await StorageService.getPokemonHistory();\r\n            return new Set(localHistory);\r\n        } catch (error) {\r\n            console.error('‚ùå Error getting local history:', error);\r\n            return new Set();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the count of unique Pokemon ever caught.\r\n     * @returns {Promise<number>} - Count of unique Pokemon in history.\r\n     */\r\n    async getHistoryCount() {\r\n        try {\r\n            const history = await this.getHistoryForUser();\r\n            return history.size;\r\n        } catch (error) {\r\n            console.error('‚ùå Error getting history count:', error);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a Pokemon has ever been caught.\r\n     * @param {number} pokemonId - The Pokemon ID to check.\r\n     * @returns {Promise<boolean>} - True if Pokemon was ever caught.\r\n     */\r\n    async hasEverCaught(pokemonId) {\r\n        try {\r\n            const history = await this.getHistoryForUser();\r\n            return history.has(pokemonId);\r\n        } catch (error) {\r\n            console.error(`‚ùå Error checking if Pokemon ${pokemonId} was ever caught:`, error);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}